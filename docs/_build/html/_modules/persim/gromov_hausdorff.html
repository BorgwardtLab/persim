
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>persim.gromov_hausdorff &#8212; Persim 0.0.9 documentation</title>
    <link rel="stylesheet" href="../../_static/better.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  </head><body>
    <header id="pageheader">
      <h1>
        <a href="../../index.html ">
          Persim 0.0.9 documentation
        </a>
        <a id="headermeta" href="https://scikit-tda.org">
            a scikit-tda project 
        </a>
      </h1> 
  </header>
  <div class="related top">
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
  <nav id="breadcrumbs">
    <ul>
      <li><a href="../../index.html">Persim</a></li>
      <li>
        <a href="../index.html">Module code</a>
      </li> 
    </ul>
  </nav>
  </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for persim.gromov_hausdorff</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implementation of the modified Gromov-Hausdorff (mGH) distance</span>
<span class="sd">    between compact metric spaces induced by unweighted graphs based on</span>
<span class="sd">    their shortest path length. The mGH distance was first defined in</span>
<span class="sd">    &quot;Some properties of Gromov–Hausdorff distances&quot; by F. Mémoli</span>
<span class="sd">    (Discrete &amp; Computational Geometry, 2012).</span>

<span class="sd">    Author: Vladyslav Oles</span>

<span class="sd">    ===================================================================</span>

<span class="sd">    Usage examples:</span>

<span class="sd">    1) Estimating the mGH distance between 4-clique and single-vertex</span>
<span class="sd">    graph from their adjacency matrices. Note that it suffices to fill</span>
<span class="sd">    only the upper triangle of an adjacency matrix.</span>

<span class="sd">    &gt;&gt;&gt; A_G = [[0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1], [0, 0, 0, 0]]</span>
<span class="sd">    &gt;&gt;&gt; A_H = [[0]]</span>
<span class="sd">    &gt;&gt;&gt; lb, ub = gromov_hausdorff(A_G, A_H)</span>
<span class="sd">    &gt;&gt;&gt; lb, ub</span>
<span class="sd">    (0.5, 0.5)</span>

<span class="sd">    2) Estimating the mGH distance between cycle graphs of length 2 and</span>
<span class="sd">    5 from their adjacency matrices. Note that the adjacency matrices</span>
<span class="sd">    can be given in both dense and sparse SciPy formats.</span>

<span class="sd">    &gt;&gt;&gt; A_I = np.array([[0, 1], [0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; A_J = sps.csr_matrix(([1] * 5, ([0, 0, 1, 2, 3], [1, 4, 2, 3, 4])), shape=(5, 5))</span>
<span class="sd">    &gt;&gt;&gt; lb, ub = gromov_hausdorff(A_I, A_J)</span>
<span class="sd">    &gt;&gt;&gt; print(lb, ub)</span>
<span class="sd">    (0.5, 1.0)</span>

<span class="sd">    3) Estimating all pairwise mGH distances between multiple graphs</span>
<span class="sd">    from their adjacency matrices as an iterable.</span>

<span class="sd">    &gt;&gt;&gt; As = [A_G, A_H, A_I, A_J]</span>
<span class="sd">    &gt;&gt;&gt; LB, UB = gromov_hausdorff(As)</span>
<span class="sd">    &gt;&gt;&gt; LB</span>
<span class="sd">    [[0.  0.5 0.5 0.5]</span>
<span class="sd">     [0.5 0.  0.5 1. ]</span>
<span class="sd">     [0.5 0.5 0.  0.5]</span>
<span class="sd">     [0.5 1.  0.5 0. ]]</span>
<span class="sd">    &gt;&gt;&gt; UB</span>
<span class="sd">    [[0.  0.5 0.5 0.5]</span>
<span class="sd">     [0.5 0.  0.5 1. ]</span>
<span class="sd">     [0.5 0.5 0.  1. ]</span>
<span class="sd">     [0.5 1.  1.  0. ]]</span>

<span class="sd">    ===================================================================</span>

<span class="sd">    Notations:</span>

<span class="sd">    |X| denotes the number of elements in set X.</span>

<span class="sd">    X → Y denotes the set of all mappings of set X into set Y.</span>

<span class="sd">    V(G) denotes vertex set of graph G.</span>

<span class="sd">    mGH(X, Y) denotes the modified Gromov-Hausdorff distance between</span>
<span class="sd">    compact metric spaces X and Y.</span>

<span class="sd">    ===================================================================</span>

<span class="sd">    Glossary:</span>

<span class="sd">    Distance matrix of metric space X is a |X|×|X| matrix whose</span>
<span class="sd">    (i, j)-th entry holds the distance between i-th and j-th points of</span>
<span class="sd">    X. By the properties of a metric, distance matrices are symmetric</span>
<span class="sd">    and non-negative, their diagonal entries are 0 and off-diagonal</span>
<span class="sd">    entries are positive.</span>

<span class="sd">    Curvature is a generalization of distance matrix that allows</span>
<span class="sd">    repetitions in the underlying points of a metric space. Curvature</span>
<span class="sd">    of an n-tuple of points from metric space X is an n×n matrix whose</span>
<span class="sd">    (i, j)-th entry holds the distance between the points from i-th and</span>
<span class="sd">    j-th positions of the tuple. Since these points need not be</span>
<span class="sd">    distinct, the off-diagonal entries of a curvature can equal 0.</span>

<span class="sd">    n-th curvature set of metric space X is the set of all curvatures</span>
<span class="sd">    of X that are of size n×n.</span>

<span class="sd">    d-bounded curvature for some d &gt; 0 is a curvature whose</span>
<span class="sd">    off-diagonal entries are all ≥ d.</span>

<span class="sd">    Positive-bounded curvature is a curvature whose off-diagonal</span>
<span class="sd">    entries are all positive, i.e. the points in the underlying tuple</span>
<span class="sd">    are distinct. Equivalently, positive-bounded curvatures are</span>
<span class="sd">    distance matrices on the subsets of a metric space.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">sps</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.csgraph</span> <span class="k">import</span> <span class="n">shortest_path</span><span class="p">,</span> <span class="n">connected_components</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;gromov_hausdorff&quot;</span><span class="p">]</span>


<span class="c1"># To sample √|X| * log (|X| + 1) mappings from X → Y by default.</span>
<span class="n">DEFAULT_MAPPING_SAMPLE_SIZE_ORDER</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>


<div class="viewcode-block" id="gromov_hausdorff"><a class="viewcode-back" href="../../reference/stubs/persim.gromov_hausdorff.html#persim.gromov_hausdorff">[docs]</a><span class="k">def</span> <span class="nf">gromov_hausdorff</span><span class="p">(</span>
        <span class="n">A_G</span><span class="p">,</span> <span class="n">A_H</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mapping_sample_size_order</span><span class="o">=</span><span class="n">DEFAULT_MAPPING_SAMPLE_SIZE_ORDER</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estimate the mGH distance between simple unweighted graphs,</span>
<span class="sd">    represented as compact metric spaces based on their shortest</span>
<span class="sd">    path lengths.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    A_G: np.array (|V(G)|×|V(G)|)</span>
<span class="sd">        (Sparse) adjacency matrix of graph G, or an iterable of</span>
<span class="sd">        adjacency matrices if A_H=None.</span>
<span class="sd">    A_H: np.array (|V(H)|×|V(H)|)</span>
<span class="sd">        (Sparse) adjacency matrix of graph H, or None.</span>
<span class="sd">    mapping_sample_size_order: np.array (2)</span>
<span class="sd">        Parameter that regulates the number of mappings to sample when</span>
<span class="sd">        tightening upper bound of the mGH distance.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    lb: float</span>
<span class="sd">        Lower bound of the mGH distance, or a square matrix holding</span>
<span class="sd">        lower bounds of pairwise mGH distances if A_H=None.</span>
<span class="sd">    ub: float</span>
<span class="sd">        Upper bound of the mGH distance, or a square matrix holding</span>
<span class="sd">        upper bounds of pairwise mGH distances if A_H=None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Form iterable with adjacency matrices.</span>
    <span class="k">if</span> <span class="n">A_H</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">A_G</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;estimate_between_unweighted_graphs&#39; needs at least&quot;</span>
                             <span class="s2">&quot;2 graphs to discriminate&quot;</span><span class="p">)</span>
        <span class="n">As</span> <span class="o">=</span> <span class="n">A_G</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">As</span> <span class="o">=</span> <span class="p">(</span><span class="n">A_G</span><span class="p">,</span> <span class="n">A_H</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">As</span><span class="p">)</span>
    <span class="c1"># Find lower and upper bounds of each pairwise mGH distance between</span>
    <span class="c1"># the graphs.</span>
    <span class="n">lbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="n">ubs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="c1"># Transform adjacency matrices of a pair of graphs to</span>
            <span class="c1"># distance matrices.</span>
            <span class="n">D_X</span> <span class="o">=</span> <span class="n">make_distance_matrix_from_adjacency_matrix</span><span class="p">(</span><span class="n">As</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">D_Y</span> <span class="o">=</span> <span class="n">make_distance_matrix_from_adjacency_matrix</span><span class="p">(</span><span class="n">As</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="c1"># Find lower and upper bounds of the mGH distance between</span>
            <span class="c1"># the pair of graphs.</span>
            <span class="n">lbs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">ubs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">estimate</span><span class="p">(</span>
                <span class="n">D_X</span><span class="p">,</span> <span class="n">D_Y</span><span class="p">,</span> <span class="n">mapping_sample_size_order</span><span class="o">=</span><span class="n">mapping_sample_size_order</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">A_H</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Symmetrize matrices with lower and upper bounds of pairwise</span>
        <span class="c1"># mGH distances between the graphs.</span>
        <span class="n">lower_triangle_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tril_indices</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">lbs</span><span class="p">[</span><span class="n">lower_triangle_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">lbs</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">lower_triangle_indices</span><span class="p">]</span>
        <span class="n">ubs</span><span class="p">[</span><span class="n">lower_triangle_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">ubs</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">lower_triangle_indices</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">lbs</span><span class="p">,</span> <span class="n">ubs</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lbs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ubs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span></div>


<span class="k">def</span> <span class="nf">make_distance_matrix_from_adjacency_matrix</span><span class="p">(</span><span class="n">A_G</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represent simple unweighted graph as compact metric space (with</span>
<span class="sd">    integer distances) based on its shortest path lengths.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    A_G: np.array (|V(G)|×|V(G)|)</span>
<span class="sd">        (Sparse) adjacency matrix of simple unweighted graph G.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    D_G: np.array (|V(G)|×|V(G)|)</span>
<span class="sd">        (Dense) distance matrix of G, represented as compact</span>
<span class="sd">        metric space based on its shortest path lengths.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert adjacency matrix to SciPy format if needed.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">sps</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">A_G</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A_G</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">A_G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">A_G</span><span class="p">)</span>

    <span class="c1"># Compile distance matrix of the graph based on its shortest path</span>
    <span class="c1"># lengths.</span>
    <span class="n">D_G</span> <span class="o">=</span> <span class="n">shortest_path</span><span class="p">(</span><span class="n">A_G</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unweighted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># Ensure compactness of metric space, represented by distance</span>
    <span class="c1"># matrix.</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">D_G</span><span class="p">)):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;disconnected graph is approximated by its largest connected component&quot;</span><span class="p">)</span>
        <span class="c1"># Extract largest connected component of the graph.</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">components_by_vertex</span> <span class="o">=</span> <span class="n">connected_components</span><span class="p">(</span><span class="n">A_G</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">components</span><span class="p">,</span> <span class="n">component_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">components_by_vertex</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">largest_component</span> <span class="o">=</span> <span class="n">components</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">component_sizes</span><span class="p">)]</span>
        <span class="n">D_G</span> <span class="o">=</span> <span class="n">D_G</span><span class="p">[</span><span class="n">components_by_vertex</span> <span class="o">==</span> <span class="n">largest_component</span><span class="p">]</span>

    <span class="c1"># Cast distance matrix to optimal integer type.</span>
    <span class="n">D_G</span> <span class="o">=</span> <span class="n">cast_distance_matrix_to_optimal_integer_type</span><span class="p">(</span><span class="n">D_G</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">D_G</span>


<span class="k">def</span> <span class="nf">cast_distance_matrix_to_optimal_integer_type</span><span class="p">(</span><span class="n">D_X</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cast distance matrix to smallest signed integer type, sufficient</span>
<span class="sd">    to hold all its distances.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    D_X: np.array (|X|×|X|)</span>
<span class="sd">        Distance matrix of a compact metric space X with integer</span>
<span class="sd">        distances.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    D: np.array (|X|×|X|)</span>
<span class="sd">        Distance matrix of the metric space, cast to optimal type.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">max_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">D_X</span><span class="p">)</span>
    <span class="c1"># Type is signed integer to allow subtractions.</span>
    <span class="n">optimal_int_type</span> <span class="o">=</span> <span class="n">determine_optimal_int_type</span><span class="p">(</span><span class="n">max_distance</span><span class="p">)</span>
    <span class="n">D_X</span> <span class="o">=</span> <span class="n">D_X</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">optimal_int_type</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">D_X</span>


<span class="k">def</span> <span class="nf">determine_optimal_int_type</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine smallest signed integer type sufficient to hold a value.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    value: non-negative integer</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    optimal_int_type: np.dtype</span>
<span class="sd">        Optimal signed integer type to hold the value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">feasible_int_types</span> <span class="o">=</span> <span class="p">(</span><span class="n">int_type</span> <span class="k">for</span> <span class="n">int_type</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">]</span>
                          <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">int_type</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">optimal_int_type</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">feasible_int_types</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;value </span><span class="si">{}</span><span class="s2"> too large to be stored as unsigned integer&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">optimal_int_type</span>


<span class="k">def</span> <span class="nf">estimate</span><span class="p">(</span><span class="n">D_X</span><span class="p">,</span> <span class="n">D_Y</span><span class="p">,</span> <span class="n">mapping_sample_size_order</span><span class="o">=</span><span class="n">DEFAULT_MAPPING_SAMPLE_SIZE_ORDER</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For X, Y metric spaces, find lower and upper bounds of mGH(X, Y).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    D_X: np.array (|X|×|X|)</span>
<span class="sd">        Integer distance matrix of X.</span>
<span class="sd">    D_Y: np.array (|Y|×|Y|)</span>
<span class="sd">        Integer distance matrix of Y.</span>
<span class="sd">    mapping_sample_size_order: np.array (2)</span>
<span class="sd">        Parameter that regulates the number of mappings to sample when</span>
<span class="sd">        tightening upper bound of mGH(X, Y).</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    lb: float</span>
<span class="sd">        Lower bound of mGH(X, Y).</span>
<span class="sd">    ub: float</span>
<span class="sd">        Upper bound of mGH(X, Y).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Ensure distance matrices are of integer type.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">D_X</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">D_Y</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;non-integer metrics are not yet supported&quot;</span><span class="p">)</span>
    <span class="c1"># Cast distance matrices to signed integer type to allow</span>
    <span class="c1"># subtractions.</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">D_X</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint</span><span class="p">):</span>
        <span class="n">D_X</span> <span class="o">=</span> <span class="n">cast_distance_matrix_to_optimal_integer_type</span><span class="p">(</span><span class="n">D_X</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">D_Y</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint</span><span class="p">):</span>
        <span class="n">D_Y</span> <span class="o">=</span> <span class="n">cast_distance_matrix_to_optimal_integer_type</span><span class="p">(</span><span class="n">D_Y</span><span class="p">)</span>
    <span class="c1"># Estimate mGH(X, Y).</span>
    <span class="n">double_lb</span> <span class="o">=</span> <span class="n">find_lb</span><span class="p">(</span><span class="n">D_X</span><span class="p">,</span> <span class="n">D_Y</span><span class="p">)</span>
    <span class="n">double_ub</span> <span class="o">=</span> <span class="n">find_ub</span><span class="p">(</span>
        <span class="n">D_X</span><span class="p">,</span> <span class="n">D_Y</span><span class="p">,</span> <span class="n">mapping_sample_size_order</span><span class="o">=</span><span class="n">mapping_sample_size_order</span><span class="p">,</span> <span class="n">double_lb</span><span class="o">=</span><span class="n">double_lb</span><span class="p">)</span>

    <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">double_lb</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">double_ub</span>


<span class="k">def</span> <span class="nf">find_lb</span><span class="p">(</span><span class="n">D_X</span><span class="p">,</span> <span class="n">D_Y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For X, Y metric spaces, find lower bound of mGH(X, Y).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    D_X: np.array (|X|×|X|)</span>
<span class="sd">        Integer distance matrix of X.</span>
<span class="sd">    D_Y: np.array (|Y|×|Y|)</span>
<span class="sd">        Integer distance matrix of Y.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    double_lb: float</span>
<span class="sd">        Lower bound of 2*mGH(X, Y).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">diam_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">D_X</span><span class="p">)</span>
    <span class="n">diam_Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">D_Y</span><span class="p">)</span>
    <span class="n">max_distance</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">diam_X</span><span class="p">,</span> <span class="n">diam_Y</span><span class="p">)</span>
    <span class="c1"># Obtain trivial lower bound of 2*mGH(X, Y) from</span>
    <span class="c1"># 1) mGH(X, Y) ≥ 0.5*|diam X - diam Y|;</span>
    <span class="c1"># 2) mGH(X, Y) = 0 if and only if X and Y are isometric.</span>
    <span class="n">trivial_double_lb</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">diam_X</span> <span class="o">-</span> <span class="n">diam_Y</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">D_X</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">D_Y</span><span class="p">)))</span>
    <span class="c1"># Initialize lower bound of 2*mGH(X, Y).</span>
    <span class="n">double_lb</span> <span class="o">=</span> <span class="n">trivial_double_lb</span>
    <span class="c1"># Try tightening the lower bound.</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">max_distance</span>
    <span class="k">while</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="n">double_lb</span><span class="p">:</span>
        <span class="c1"># Try proving 2*mGH(X, Y) ≥ d using d-bounded curvatures of</span>
        <span class="c1"># X and Y of size 3×3 or larger. 2×2 curvatures are already</span>
        <span class="c1"># accounted for in trivial lower bound.</span>

        <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="n">diam_X</span><span class="p">:</span>
            <span class="n">K</span> <span class="o">=</span> <span class="n">find_largest_size_bounded_curvature</span><span class="p">(</span><span class="n">D_X</span><span class="p">,</span> <span class="n">diam_X</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">K</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">confirm_lb_using_bounded_curvature</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">D_Y</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">):</span>
                <span class="n">double_lb</span> <span class="o">=</span> <span class="n">d</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="n">double_lb</span> <span class="ow">and</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="n">diam_Y</span><span class="p">:</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">find_largest_size_bounded_curvature</span><span class="p">(</span><span class="n">D_Y</span><span class="p">,</span> <span class="n">diam_Y</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">confirm_lb_using_bounded_curvature</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">D_X</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">):</span>
                <span class="n">double_lb</span> <span class="o">=</span> <span class="n">d</span>

        <span class="n">d</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">double_lb</span>


<span class="k">def</span> <span class="nf">find_largest_size_bounded_curvature</span><span class="p">(</span><span class="n">D_X</span><span class="p">,</span> <span class="n">diam_X</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find a largest-size d-bounded curvature of metric space X.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    D_X: np.array (|X|×|X|)</span>
<span class="sd">        Integer distance matrix of X.</span>
<span class="sd">    diam_X: int</span>
<span class="sd">        Largest distance in X.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    K: np.array (N×N)</span>
<span class="sd">        d-bounded curvature of X of largest size; N ≤ |K|.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialize curvature K with entire distance matrix.</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">D_X</span>
    <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">K</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">triu_indices_from</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">):</span>
        <span class="c1"># Pick a row (and column) with highest number of off-diagonal</span>
        <span class="c1"># distances &lt; d, then with smallest sum of off-diagonal</span>
        <span class="c1"># distances ≥ d.</span>
        <span class="n">K_rows_sortkeys</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">K</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">K</span><span class="p">)</span> <span class="o">*</span> <span class="n">diam_X</span><span class="p">)</span> <span class="o">+</span> \
                      <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_less</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">d</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>
        <span class="n">row_to_remove</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">K_rows_sortkeys</span><span class="p">)</span>
        <span class="c1"># Remove the point from K.</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">row_to_remove</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">row_to_remove</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">K</span>


<span class="k">def</span> <span class="nf">confirm_lb_using_bounded_curvature</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">D_Y</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For X, Y metric spaces, try to confirm 2*mGH(X, Y) ≥ d</span>
<span class="sd">    using K, a d-bounded curvature of X.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d: int</span>
<span class="sd">        Lower bound candidate for 2*mGH(X, Y).</span>
<span class="sd">    K: np.array (N×N)</span>
<span class="sd">        d-bounded curvature of X; N ≥ 3.</span>
<span class="sd">    D_Y: np.array (|Y|×|Y|)</span>
<span class="sd">        Integer distance matrix of Y.</span>
<span class="sd">    max_distance: int</span>
<span class="sd">        Largest distance in X and Y.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    lb_is_confirmed: bool</span>
<span class="sd">        Whether confirmed that 2*mGH(X, Y) ≥ d.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If K exceeds D_Y in size, the Hausdorff distance between the n-th</span>
    <span class="c1"># curvature sets of X and Y is ≥ d, entailing 2*mGH(X, Y) ≥ d.</span>
    <span class="n">lb_is_confirmed</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">D_Y</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">K</span><span class="p">)</span> <span class="ow">or</span> <span class="n">confirm_lb_using_bounded_curvature_principal_subrows</span><span class="p">(</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">D_Y</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">lb_is_confirmed</span>


<span class="k">def</span> <span class="nf">confirm_lb_using_bounded_curvature_principal_subrows</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">D_Y</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For X, Y metric spaces, and K, a d-bounded curvature of X, try to</span>
<span class="sd">    confirm 2*mGH(X, Y) ≥ d using selected rows of selected principal</span>
<span class="sd">    submatrices of K.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d: int</span>
<span class="sd">        Lower bound candidate for 2*mGH(X, Y).</span>
<span class="sd">    K: np.array (N×N)</span>
<span class="sd">        d-bounded curvature of X; N ≥ 3.</span>
<span class="sd">    D_Y: np.array (|Y|×|Y|)</span>
<span class="sd">        Integer distance matrix of Y; |Y| ≥ N.</span>
<span class="sd">    max_distance: int</span>
<span class="sd">        Largest distance in X and Y.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    lb_is_confirmed: bool</span>
<span class="sd">        Whether confirmed that 2*mGH(X, Y) ≥ d.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Represent rows of D_Y as distance distributions.</span>
    <span class="n">D_Y_rows_distance_distributions</span> <span class="o">=</span> \
        <span class="n">represent_distance_matrix_rows_as_distributions</span><span class="p">(</span><span class="n">D_Y</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">)</span>

    <span class="c1"># For each m ≥ 3, select those rows of m×m principal</span>
    <span class="c1"># submatrices of K whose entries are the largest, represent them as</span>
    <span class="c1"># distance distributions, and try using them to confirm that the</span>
    <span class="c1"># Hausdorff distance between m-th curvature sets of X and Y is ≥ d,</span>
    <span class="c1"># entailing 2*mGH(X, Y) ≥ d. The case of m = 2 is disregarded as</span>
    <span class="c1"># 2×2 curvatures are already accounted for in trivial lower bound.</span>
    <span class="n">K_principal_subrows_distance_distributions</span> <span class="o">=</span> <span class="n">find_unique_maximal_distributions</span><span class="p">(</span>
        <span class="n">represent_distance_matrix_rows_as_distributions</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">))</span>
    <span class="n">lb_is_confirmed</span> <span class="o">=</span> <span class="n">confirm_distance_between_curvature_sets_lb</span><span class="p">(</span>
        <span class="n">K_principal_subrows_distance_distributions</span><span class="p">,</span> <span class="n">D_Y_rows_distance_distributions</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">K</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">lb_is_confirmed</span> <span class="ow">and</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">K_principal_subrows_distance_distributions</span> <span class="o">=</span> <span class="n">find_unique_maximal_distributions</span><span class="p">(</span>
            <span class="n">remove_smallest_entry_from_vectors</span><span class="p">(</span>
                <span class="n">K_principal_subrows_distance_distributions</span><span class="p">))</span>
        <span class="n">lb_is_confirmed</span> <span class="o">=</span> <span class="n">confirm_distance_between_curvature_sets_lb</span><span class="p">(</span>
            <span class="n">K_principal_subrows_distance_distributions</span><span class="p">,</span> <span class="n">D_Y_rows_distance_distributions</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

        <span class="n">m</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">lb_is_confirmed</span>


<span class="k">def</span> <span class="nf">represent_distance_matrix_rows_as_distributions</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represent each row of a distance matrix by frequency distribution</span>
<span class="sd">    of distances in it. The only distance 0 in each row is omitted.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    D: np.array (N×N)</span>
<span class="sd">        Integer distance matrix.</span>
<span class="sd">    max_distance: int</span>
<span class="sd">        Max distance of the distribution, upper bound of entries in D.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    D_rows_distributons: np.array (N×max_distance)</span>
<span class="sd">        Each row holds frequencies of each distance from 1 to</span>
<span class="sd">        max_distance in the corresponding row of D:</span>
<span class="sd">        (i, j)-th entry holds frequency of distance (max_distance - j)</span>
<span class="sd">        in the i-th row of D.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Add imaginary part to distinguish identical distances from</span>
    <span class="c1"># different rows of D.</span>
    <span class="n">unique_distances</span><span class="p">,</span> <span class="n">distance_frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
        <span class="n">D</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">D</span><span class="p">))[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># Type is signed integer to allow subtractions.</span>
    <span class="n">optimal_int_type</span> <span class="o">=</span> <span class="n">determine_optimal_int_type</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">D</span><span class="p">))</span>
    <span class="n">D_rows_distributons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">D</span><span class="p">),</span> <span class="n">max_distance</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">optimal_int_type</span><span class="p">)</span>
    <span class="c1"># Construct index pairs for distance frequencies, so that the</span>
    <span class="c1"># frequencies of larger distances appear on the left.</span>
    <span class="n">distance_frequencies_index_pairs</span> <span class="o">=</span> \
        <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">unique_distances</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">optimal_int_type</span><span class="p">),</span>
         <span class="n">max_distance</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">unique_distances</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">max_distance</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
    <span class="c1"># Fill frequency distributions of D rows.</span>
    <span class="n">D_rows_distributons</span><span class="p">[</span><span class="n">distance_frequencies_index_pairs</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance_frequencies</span>
    <span class="c1"># Remove (unit) frequency of distance 0 from each row.</span>
    <span class="n">D_rows_distributons</span> <span class="o">=</span> <span class="n">D_rows_distributons</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">D_rows_distributons</span>


<span class="k">def</span> <span class="nf">find_unique_maximal_distributions</span><span class="p">(</span><span class="n">distributions</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given some vectors represented as frequency distributions of their</span>
<span class="sd">    entries, find unique maximal vectors under the following partial</span>
<span class="sd">    order: for r, s vectors, r &lt; s if and only if there exists</span>
<span class="sd">    bijection between the individual entries of r and s, under which</span>
<span class="sd">    each entry in r is smaller than the corresponding entry in s.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    distributions: np.array (N×max_distance)</span>
<span class="sd">        Frequency distributions of N positive vectors of the same size,</span>
<span class="sd">        i.e. the row sums are all equal.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    unique_maximal_distributions: np.array (M, max_distance)</span>
<span class="sd">        Unique frequency distributions of the maximal vectors; M ≤ N.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pairwise_distribution_differences</span> <span class="o">=</span> \
        <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">distributions</span> <span class="o">-</span> <span class="n">distributions</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">pairwise_distribution_less_thans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">pairwise_distribution_differences</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">pairwise_distribution_differences</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">distributions_are_maximal</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">pairwise_distribution_less_thans</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># `np.unique` replaced for compatibility with Python 3.4/NumPy 1.12.</span>
    <span class="c1"># unique_maximal_distributions = np.unique(distributions[distributions_are_maximal], axis=0)</span>
    <span class="n">unique_maximal_distributions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
        <span class="p">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">distribution</span><span class="p">)</span> <span class="k">for</span> <span class="n">distribution</span> <span class="ow">in</span> <span class="n">distributions</span><span class="p">[</span><span class="n">distributions_are_maximal</span><span class="p">]})</span>

    <span class="k">return</span> <span class="n">unique_maximal_distributions</span>


<span class="k">def</span> <span class="nf">confirm_distance_between_curvature_sets_lb</span><span class="p">(</span><span class="n">rs_distributions</span><span class="p">,</span> <span class="n">D_Y_rows_distributions</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For X, Y metric spaces, try to confirm that the Hausdorff distance</span>
<span class="sd">    between the m-th curvature sets of X and Y is ≥ d, using a row of</span>
<span class="sd">    some m×m d-bounded curvature of X.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rs_distributions: np.array (m×max_distance)</span>
<span class="sd">        Frequency distributions of the rows of some m×m d-bounded</span>
<span class="sd">        curvature of X; m ≥ 3.</span>
<span class="sd">    D_Y_rows_distributions: np.array (|Y|×max_distance)</span>
<span class="sd">        Frequency distributions of the rows of distance matrix of Y;</span>
<span class="sd">        |Y| ≥ m.</span>
<span class="sd">    d: int</span>
<span class="sd">        Lower bound candidate for the Hausdorff distance between the</span>
<span class="sd">        m-th curvature sets of X and Y.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    distance_between_curvature_sets_lb_is_confirmed: bool</span>
<span class="sd">        Whether confirmed that the Hausdorff distance between the</span>
<span class="sd">        m-th curvature sets of X and Y is ≥ d.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># For each r, k-th row of an m×m d-bounded curvature of X for some</span>
    <span class="c1"># k ∈ 1,...,m, check if the l∞-distance from r to the set of k-th</span>
    <span class="c1"># rows of positive-bounded m×m curvatures of Y is ≥ d, then the</span>
    <span class="c1"># Hausdorff distance between m-th curvature sets of X and Y is ≥ d.</span>
    <span class="n">distance_between_curvature_sets_lb_is_confirmed</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">distance_between_curvature_sets_lb_is_confirmed</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">rs_distributions</span><span class="p">):</span>
        <span class="n">distance_between_curvature_sets_lb_is_confirmed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">distance_between_curvature_sets_lb_is_confirmed</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">D_Y_rows_distributions</span><span class="p">):</span>
            <span class="n">distance_between_curvature_sets_lb_is_confirmed</span> <span class="o">=</span> \
                <span class="n">check_distance_to_permuted_principal_subrows_lb</span><span class="p">(</span>
                    <span class="n">rs_distributions</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">D_Y_rows_distributions</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">d</span><span class="p">)</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">distance_between_curvature_sets_lb_is_confirmed</span>


<span class="k">def</span> <span class="nf">remove_smallest_entry_from_vectors</span><span class="p">(</span><span class="n">distributions</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove smallest entry from each of the given vectors, represented</span>
<span class="sd">    as frequency distributions of their entries.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    distributions: np.array (N×max_distance)</span>
<span class="sd">        Frequency distributions of N positive vectors.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    updated_distributions: np.array (N×max_distance)</span>
<span class="sd">        Frequency distributions of N vectors, obtained by removing</span>
<span class="sd">        smallest entry from each of the input vectors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">updated_distributions</span> <span class="o">=</span> <span class="n">distributions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># Find smallest entry in each distribution.</span>
    <span class="n">max_distance</span> <span class="o">=</span> <span class="n">distributions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">smallest_entry_indices</span> <span class="o">=</span> <span class="n">max_distance</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">distributions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Decrease frequency of smallest entry by 1 in each distribution.</span>
    <span class="n">updated_distributions</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">distributions</span><span class="p">)),</span> <span class="n">smallest_entry_indices</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">updated_distributions</span>


<span class="k">def</span> <span class="nf">check_distance_to_permuted_principal_subrows_lb</span><span class="p">(</span><span class="n">r_distribution</span><span class="p">,</span> <span class="n">s_distribution</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For vectors r of size m and s, a row of some n×n distance matrix D,</span>
<span class="sd">    check if l∞-distance from r to the set P, comprised of permutations</span>
<span class="sd">    of those subvectors of s that are a row of some m×m principal</span>
<span class="sd">    submatrix of D, is ≥ d.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    r_distribution: np.array (max_distance)</span>
<span class="sd">        Frequency distribution of r, positive integer vector.</span>
<span class="sd">    s_distribution: np.array (max_distance)</span>
<span class="sd">        Frequency distribution of s, positive integer vector no smaller</span>
<span class="sd">        in length than r;</span>
<span class="sd">    d: int</span>
<span class="sd">        Lower bound candidate for l∞-distance from r to P; d &gt; 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    d_is_distance_to_permuted_principal_subrows_lb: bool</span>
<span class="sd">        Whether l∞-distance from r to P is ≥ d.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">next_i_and_j</span><span class="p">(</span><span class="n">min_i</span><span class="p">,</span> <span class="n">min_j</span><span class="p">):</span>
        <span class="c1"># Find reversed r distribution index of smallest r entries yet</span>
        <span class="c1"># to be assigned. Then find index in reversed s distribution of</span>
        <span class="c1"># smallest s entries to which the r entries can be assigned to.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">reversed_r_distribution</span><span class="p">))</span>
                     <span class="k">if</span> <span class="n">reversed_r_distribution</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="c1"># All r entries are assigned.</span>
            <span class="n">i</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">min_j</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">next_j</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">min_j</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span>

    <span class="k">def</span> <span class="nf">next_j</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">min_j</span><span class="p">):</span>
        <span class="c1"># Find reversed s distribution index of smallest s entries to</span>
        <span class="c1"># which r entries, corresponding to a given reversed r</span>
        <span class="c1"># distribution index, can be assigned to.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_j</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
                                                 <span class="nb">len</span><span class="p">(</span><span class="n">reversed_s_distribution</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                     <span class="k">if</span> <span class="n">reversed_s_distribution</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="c1"># No s entries left to assign the particular r entries to.</span>
            <span class="n">j</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">j</span>

    <span class="c1"># Copy to allow modifications and stay pure; reverse for the</span>
    <span class="c1"># frequencies of smaller entries to come first, to be compatible</span>
    <span class="c1"># even with distributions of different lengths.</span>
    <span class="n">reversed_r_distribution</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">r_distribution</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">reversed_s_distribution</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">s_distribution</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="c1"># Injectively assign r entries to s entries if their difference</span>
    <span class="c1"># is &lt; d, going from smallest to largest entries in both r and s,</span>
    <span class="c1"># until all r entries are assigned or such assignment proves</span>
    <span class="c1"># unfeasible.</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">next_i_and_j</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">j</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">reversed_r_distribution</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">reversed_s_distribution</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="n">reversed_s_distribution</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-=</span> <span class="n">reversed_r_distribution</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">reversed_r_distribution</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">next_i_and_j</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reversed_r_distribution</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">reversed_s_distribution</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">reversed_s_distribution</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">next_j</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>

    <span class="c1"># The assignment is feasible if and only if |r - p| &lt; d for some</span>
    <span class="c1"># p ∈ P, and therefore infeasible if and only if l∞-distance from</span>
    <span class="c1"># r to P is ≥ d.</span>
    <span class="n">d_is_distance_to_permuted_principal_subrows_lb</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">d_is_distance_to_permuted_principal_subrows_lb</span>


<span class="k">def</span> <span class="nf">find_ub</span><span class="p">(</span><span class="n">D_X</span><span class="p">,</span> <span class="n">D_Y</span><span class="p">,</span> <span class="n">mapping_sample_size_order</span><span class="o">=</span><span class="n">DEFAULT_MAPPING_SAMPLE_SIZE_ORDER</span><span class="p">,</span> <span class="n">double_lb</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For X, Y metric spaces, find upper bound of mGH(X, Y).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    D_X: np.array (|X|×|X|)</span>
<span class="sd">        Integer distance matrix of X.</span>
<span class="sd">    D_Y: np.array (|Y|×|Y|)</span>
<span class="sd">        Integer distance matrix of Y.</span>
<span class="sd">    mapping_sample_size_order: np.array (2)</span>
<span class="sd">        Parameter that regulates the number of mappings to sample when</span>
<span class="sd">        tightening the upper bound.</span>
<span class="sd">    double_lb: float</span>
<span class="sd">        Lower bound of 2*mGH(X, Y).</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    double_ub: float</span>
<span class="sd">        Upper bound of 2*mGH(X, Y).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Find upper bound of smallest distortion of a mapping in X → Y.</span>
    <span class="n">ub_of_X_to_Y_min_distortion</span> <span class="o">=</span> <span class="n">find_ub_of_min_distortion</span><span class="p">(</span>
        <span class="n">D_X</span><span class="p">,</span> <span class="n">D_Y</span><span class="p">,</span> <span class="n">mapping_sample_size_order</span><span class="o">=</span><span class="n">mapping_sample_size_order</span><span class="p">,</span> <span class="n">goal_distortion</span><span class="o">=</span><span class="n">double_lb</span><span class="p">)</span>
    <span class="c1"># Find upper bound of smallest distortion of a mapping in Y → X.</span>
    <span class="n">ub_of_Y_to_X_min_distortion</span> <span class="o">=</span> <span class="n">find_ub_of_min_distortion</span><span class="p">(</span>
        <span class="n">D_Y</span><span class="p">,</span> <span class="n">D_X</span><span class="p">,</span> <span class="n">mapping_sample_size_order</span><span class="o">=</span><span class="n">mapping_sample_size_order</span><span class="p">,</span>
        <span class="n">goal_distortion</span><span class="o">=</span><span class="n">ub_of_X_to_Y_min_distortion</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">ub_of_X_to_Y_min_distortion</span><span class="p">,</span> <span class="n">ub_of_Y_to_X_min_distortion</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">find_ub_of_min_distortion</span><span class="p">(</span><span class="n">D_X</span><span class="p">,</span> <span class="n">D_Y</span><span class="p">,</span>
                              <span class="n">mapping_sample_size_order</span><span class="o">=</span><span class="n">DEFAULT_MAPPING_SAMPLE_SIZE_ORDER</span><span class="p">,</span>
                              <span class="n">goal_distortion</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For X, Y metric spaces, finds upper bound of smallest distortion of</span>
<span class="sd">    a mapping in X → Y by heuristically constructing some mappings and</span>
<span class="sd">    choosing the smallest distortion in the sample.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    D_X: np.array (|X|×|X|)</span>
<span class="sd">        Integer distance matrix of X.</span>
<span class="sd">    D_Y: np.array (|Y|×|Y|)</span>
<span class="sd">        Integer distance matrix of Y.</span>
<span class="sd">    mapping_sample_size_order: np.array (2)</span>
<span class="sd">        Exponents of |X| and log (|X|+1) in their product that defines</span>
<span class="sd">        how many mappings from X → Y to sample.</span>
<span class="sd">    goal_distortion: float</span>
<span class="sd">        No need to look for distortion smaller than this.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    ub_of_min_distortion: float</span>
<span class="sd">        Upper bound of smallest distortion of a mapping in X → Y.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Compute the numper of mappings to sample.</span>
    <span class="n">n_mappings_to_sample</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">D_X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">D_X</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span><span class="o">**</span><span class="n">mapping_sample_size_order</span><span class="p">)))</span>
    <span class="c1"># Construct each mapping in X → Y in |X| steps by choosing the image</span>
    <span class="c1"># of π(i)-th point in X at i-th step, where π is randomly sampled</span>
    <span class="c1"># |X|-permutation. Image of each point is chosen to minimize the</span>
    <span class="c1"># intermediate distortion at each step.</span>
    <span class="n">permutations_generator</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">D_X</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_mappings_to_sample</span><span class="p">))</span>
    <span class="n">ub_of_min_distortion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">goal_distortion_is_matched</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">all_sampled_permutations_are_tried</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">pi</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">permutations_generator</span><span class="p">)</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">goal_distortion_is_matched</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">all_sampled_permutations_are_tried</span><span class="p">:</span>
        <span class="n">mapped_xs_images</span><span class="p">,</span> <span class="n">distortion</span> <span class="o">=</span> <span class="n">construct_mapping</span><span class="p">(</span><span class="n">D_X</span><span class="p">,</span> <span class="n">D_Y</span><span class="p">,</span> <span class="n">pi</span><span class="p">)</span>
        <span class="n">ub_of_min_distortion</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">distortion</span><span class="p">,</span> <span class="n">ub_of_min_distortion</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ub_of_min_distortion</span> <span class="o">&lt;=</span> <span class="n">goal_distortion</span><span class="p">:</span>
            <span class="n">goal_distortion_is_matched</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">pi</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">permutations_generator</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="n">all_sampled_permutations_are_tried</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="n">ub_of_min_distortion</span>


<span class="k">def</span> <span class="nf">construct_mapping</span><span class="p">(</span><span class="n">D_X</span><span class="p">,</span> <span class="n">D_Y</span><span class="p">,</span> <span class="n">pi</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    # Construct a mapping from X → Y in |X| steps by choosing the image</span>
<span class="sd">    # of π(i)-th point in X at i-th step, for some |X|-permutation π.</span>
<span class="sd">    Image of each point is chosen to minimize the intermediate</span>
<span class="sd">    distortion at the corresponding step.</span>

<span class="sd">    D_X: np.array (|X|×|X|)</span>
<span class="sd">        Integer distance matrix of X.</span>
<span class="sd">    D_Y: np.array (|Y|×|Y|)</span>
<span class="sd">        Integer distance matrix of Y.</span>
<span class="sd">    pi: np.array (|X|)</span>
<span class="sd">        |X|-permutation specifying the order in which the points in X</span>
<span class="sd">        are mapped.</span>
<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    mapped_xs_images: list</span>
<span class="sd">        image of the constructed mapping.</span>
<span class="sd">    distortion: float</span>
<span class="sd">        distortion of the constructed mapping.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Map π(1)-th point in X to a random point in Y, due to the</span>
    <span class="c1"># lack of better criterion.</span>
    <span class="n">mapped_xs</span> <span class="o">=</span> <span class="p">[</span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">mapped_xs_images</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">D_Y</span><span class="p">))]</span>
    <span class="n">distortion</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># Map π(i)-th point in X for each i = 2,...,|X|.</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pi</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="c1"># Choose point in Y that minimizes the distortion after</span>
        <span class="c1"># mapping π(i)-th point in X to it.</span>
        <span class="n">bottlenecks_from_mapping_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">D_X</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">mapped_xs</span><span class="p">]</span> <span class="o">-</span> <span class="n">D_Y</span><span class="p">[:,</span> <span class="n">mapped_xs_images</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">bottlenecks_from_mapping_x</span><span class="p">)</span>
        <span class="c1"># Map π(i)-th point in X to the chosen point in Y.</span>
        <span class="n">mapped_xs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">mapped_xs_images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">distortion</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">bottlenecks_from_mapping_x</span><span class="p">[</span><span class="n">y</span><span class="p">],</span> <span class="n">distortion</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">mapped_xs_images</span><span class="p">,</span> <span class="n">distortion</span>

</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.png" alt="Logo"/>
            </a></p>
<form class="search" action="../../search.html" method="get">
  <input type="text" name="q"
   placeholder="type to search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
<script type="text/javascript">$('#searchbox').show(0);</script>

<a href=https://github.com/scikit-tda/persim>
    <p class="caption"><span class="caption-text">
        <img src="../../_static/gh_logo.png" 
        height="18px" 
        width="18px" alt="Github icon">  
        scikit-tda/persim
    </span></p>
</a> 

<p class="caption"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/Persistence Images.html">Persistence Images</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/distances.html">Distances</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/index.html">API Reference</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/Classification with persistence images.html">Persistence Images in Classification</a></li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
  <div class="related bottom">
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
  <nav id="breadcrumbs">
    <ul>
      <li><a href="../../index.html">Persim</a></li>
      <li>
        <a href="../index.html">Module code</a>
      </li> 
    </ul>
  </nav>
  </div>
  <footer id="pagefooter">&copy; 2019, Nathaniel Saul.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a>
      1.8.2.

  </footer>

  
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-124965309-3', '');
      ga('send', 'pageview');
    </script>
  
  </body>
</html>